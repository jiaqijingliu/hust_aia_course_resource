



# 第四次实验

这里需要自行修改中断号（用自己的交通灯代码，我这里因为是全交给队友搞的），就相当于加了一个子程序，然后再再在最开始加了个允许中断的东西。自行修改下即可。不怕被发现也可以照搬

```
CTR8255 EQU 0273H ; 8255控制字寄存器地址
PORT8255 EQU 0270H ; 8255A端口地址

_STACK SEGMENT STACK  
DW 100 DUP(?)  ; 定义100字的堆栈空间
_STACK ENDS 

DATA SEGMENT  
DATA ENDS 

CODE SEGMENT 
BEGIN PROC NEAR  
ASSUME CS:CODE, DS:DATA, SS:_STACK 

; 初始化
MOV AX, DATA 
MOV DS, AX 
MOV ES, AX
NOP

PUSH DX
PUSH AX

; 初始化8255芯片
MOV DX, CTR8255 ; DX指向8255控制端口
MOV AL, 80H ; 设置8255控制字：A、B、C端口都工作在方式0输出
OUT DX, AL 

; 初始化交通灯状态
MOV DX, PORT8255 ; DX指向8255数据端口
MOV AL, 00H ; 全0，所有灯亮（根据硬件连接，0亮1灭）
OUT DX, AL ; 初始状态灯全亮

; 恢复现场
POP AX
POP DX

; 设置中断向量（中断类型号106，即6AH）
PUSH AX
PUSH DS
PUSH DX
PUSH ES
MOV AX, 0  ; 中断向量表位于内存0段
MOV ES, AX
MOV BX, 1A8H ; 106×4=424=1A8H，计算中断向量地址
MOV AX, OFFSET INTLIGHT ; 设置中断服务程序的偏移地址(IP)
MOV ES:[BX], AX
MOV AX, SEG INTLIGHT ; 设置中断服务程序的段地址(CS)
MOV ES:[BX+2], AX
POP ES
POP DX
POP DS
POP AX

STI ; 开中断，设置IF=1允许中断
NOP

; 主程序循环 - 交通灯状态控制
; 状态1：东西绿灯，南北红灯（2秒）
STATE1: 
MOV DX, PORT8255
MOV AL, 10111110B ; 东西绿，南北红（0亮灯，1灭灯）
OUT DX, AL  
CALL DELAY2S ; 延时2秒
MOV CX, 3  ; 设置循环计数器为3

; 状态2：东西绿灯闪烁（闪烁3次，共约2.1秒）
STATE2: 
MOV AL, 10111111B ; 东西绿灯灭，南北红灯亮
OUT DX, AL  
PUSH CX ; 保存外层循环计数
CALL DELAY350MS ; 延时350ms
MOV AL, 10111110B ; 东西绿灯亮，南北红灯亮
OUT DX, AL  
CALL DELAY350MS ; 延时350ms
POP CX ; 恢复外层循环计数
LOOP STATE2 ; 循环3次，共约2.1秒

; 状态3：东西黄灯，南北红灯3秒）
STATE3: 
MOV AL, 10111101B ; 东西黄灯亮，南北红灯亮
OUT DX, AL  
CALL DELAY3S ; 延时3秒

; 状态4：东西红灯，南北绿灯（2秒）
STATE4: 
MOV AL, 11101011B ; 东西红灯亮，南北绿灯亮
OUT DX, AL  
CALL DELAY2S ; 延时2秒
MOV CX, 3 ; 设置循环计数器为3

; 状态5：南北绿灯闪烁（闪烁3次，共约2.1秒）
STATE5: 
MOV AL, 11111011B ; 东西红灯亮，南北绿灯灭
OUT DX, AL  
PUSH CX ; 保存外层循环计数
CALL DELAY350MS ; 延时350ms
MOV AL, 11101011B ; 东西红灯亮，南北绿灯亮
OUT DX, AL  
CALL DELAY350MS ; 延时350ms
POP CX ; 恢复外层循环计数
LOOP STATE5 ; 循环3次，共约2.1秒

; 状态6：东西红灯，南北黄灯（3秒）
STATE6: 
MOV AL, 11011011B ; 东西红灯亮，南北黄灯亮
OUT DX, AL 
CALL DELAY3S ; 延时3秒
JMP STATE1 ; 跳回状态1，形成循环

; 中断服务程序 - 特殊灯光模式（应急模式）
INTLIGHT PROC NEAR
; 保存现场
PUSH DS
PUSH AX
PUSH CX
PUSH DX

; 设置数据段
MOV AX, DATA
MOV DS, AX
MOV DX, PORT8255

; 特殊状态：黄灯全亮（应急状态）
STATE7:
MOV AL, 11011101B ; 东西黄灯亮，南北黄灯亮（应急状态）
OUT DX, AL
CALL DELAY2S ; 保持2秒

; 特殊状态：所有灯灭（闪烁效果）
MOV AL, 11111111B ; 所有灯灭
OUT DX, AL
CALL DELAY350MS ; 保持350ms

; 恢复现场
POP DX
POP CX
POP AX
POP DS

OUT DX, AL ; 这行代码可能多余，因为AL值已改变

IRET ; 中断返回
INTLIGHT ENDP

; 延时子程序 - 350毫秒延时
DELAY350MS PROC NEAR
PUSH CX
MOV CX, 350 ; 外层循环350次（350ms）
DDELAY_350MS: 
PUSH CX ; 保存外层循环计数
MOV CX, 293 ; 内层循环293次（约1ms）
DELAY_1MS_350: 
LOOP DELAY_1MS_350 ; 内层循环延时
POP CX ; 恢复外层循环计数
LOOP DDELAY_350MS ; 外层循环延时
POP CX
RET 
DELAY350MS ENDP   

; 延时子程序 - 2秒延时
DELAY2S PROC NEAR
PUSH CX
MOV CX, 2000 ; 外层循环2000次（2秒）
DDELAY_2S: 
PUSH CX ; 保存外层循环计数
MOV CX, 293 ; 内层循环293次（约1ms）
DELAY_1MS_2: 
LOOP DELAY_1MS_2 ; 内层循环延时
POP CX ; 恢复外层循环计数
LOOP DDELAY_2S ; 外层循环延时
POP CX
RET 
DELAY2S ENDP  

; 延时子程序 - 3秒延时
DELAY3S PROC NEAR
PUSH CX
MOV CX, 3000 ; 外层循环3000次（3秒）
DDELAY_3S: 
PUSH CX ; 保存外层循环计数
MOV CX, 293 ; 内层循环293次（约1ms）
DELAY_1MS_3: 
LOOP DELAY_1MS_3 ; 内层循环延时
POP CX ; 恢复外层循环计数
LOOP DDELAY_3S ; 外层循环延时
POP CX
RET 
DELAY3S ENDP  

BEGIN ENDP 
CODE ENDS 
END BEGIN
```



# 第三次实验





## 74HC138 译码器实验 

编写程序：使用82C55 的PC0、PC1、PC2、PC3、PC4、PC5 控制74HC138 的数据输入 端，及使能端，通过译码产生8 选1个选通信号，轮流点亮8个LED 指示灯。

### 译码器代码（修正）

```assembly
; 端口地址定义
CMD_8255  EQU 0273H	;8255控制寄存器地址
PC_8255  EQU 0272H  ; 8255的C端口

_STACK SEGMENT STACK
    DW 100 DUP(?)  
_STACK ENDS
DATA SEGMENT
DATA ENDS

CODE SEGMENT

START PROC NEAR
    ASSUME CS:CODE, SS:_STACK,DS:DATA
    MOV AX, DATA
    MOV DS, AX
    
    ; 初始化82C55，设置A、B、C口均为方式0输出(写入控制字)
    MOV DX, CMD_8255    ; 
    MOV AL, 80H         ; 控制字：10000000B (A、B、C口均为方式0输出)
    OUT DX, AL

    MOV CL, 0           ; CL作为循环计数器，从0到7，对应74HC138的A,B,C输入
MAIN_LOOP:
    ; 构造输出到PC口的数据
    ; 由 F7区：G1、G2A、G2B	——	D3区：PC3、PC4、PC5，故PC5-PC3 = 001B
    MOV AL, 08H         ; 使能控制码：00001000B (PC5=0, PC4=0, PC3=1)
    OR AL, CL           ; 将CL赋值给PC0-PC2

    ; 输出到82C55的PC口（即一个选通信号
    MOV DX, PC_8255       ;
    OUT DX, AL

    ; 延时，以显示亮灯
    CALL DELAY

    ; 计数器加1，并循环
    INC CL
    CMP CL, 8
    JB MAIN_LOOP        ; 如果CL < 8，继续循环，= 8 则重置CL
    MOV CL, 0          
    JMP MAIN_LOOP

; 延时
DELAY PROC
    PUSH CX;保护CX，因为上面用到了CL
    MOV CX, 0FFFFH     
DELAY_LOOP:
    LOOP DELAY_LOOP
    POP CX
    RET
DELAY ENDP

START ENDP 
CODE ENDS
END START
```





## 8253方波实验 



### 参考代码

```assembly
CMD_8253 EQU 0263H      ; 控制字寄存器地址
COUNT_0 EQU 0260H      ; 计数器0
COUNT_1 EQU 0261H      ; 计数器1

_STACK SEGMENT  STACK 
DW 100 DUP(?)    
_STACK ENDS 
DATA SEGMENT
DATA ENDS

CODE SEGMENT 
START PROC NEAR 
    ASSUME CS:CODE, SS:_STACK,DS:DATA
    MOV AX, DATA
    MOV DS, AX

    ;计数器0，设置为方式2（分频），BCD码计数，写入计数值方式为先低后高
    MOV DX, CMD_8253 
    MOV AL, 35H        ; 0011_0101————00(计数器0) 11(先低后高) 010(模式2) 1(BCD码)
    OUT DX, AL         ; 写入控制字寄存器
    
    ; 分频值取1000
    MOV DX, COUNT_0 
    MOV AL, 00H        
    OUT DX, AL 
    MOV AL, 10H        
    OUT DX, AL        

    ;计数器1，设置为方式3（方波），BCD码计数，写入计数值方式为先低后高
    MOV DX, CMD_8253 
    MOV AL, 77H        ; 控制字0111_0111————01(计数器1) 11(先低后高) 011(模式3) 1(BCD码)
    OUT DX, AL        
    
    ; 设置计数值为1000
    MOV DX, COUNT_1 
    MOV AL, 00H      
    OUT DX, AL 
    MOV AL, 10H        
    OUT DX, AL        

    JMP $     ; 计数器1输出1kHz方波信号
START ENDP 
CODE ENDS 
END START
```









# 第二次实验



## 流水灯代码（修正）

编写程序：将B4区的二片74HC244中数据读出、写入二片74HC273中；然后逐一点亮挂在74HC273上的16个发光二级管；循环执行。

开关变化时，先流水灯，

再停留在开关状态所控制的发光二极管的状态，

等待下次开关变化

```assembly
; 端口地址定义
IO244  EQU 0230H  ;244(16位)片选 
IO273  EQU 0230H  ;273(16位)片选

; 堆栈段定义
_STACK SEGMENT STACK
    DW 100 DUP(?)     ; 分配100字的堆栈空间
_STACK ENDS

; 数据段定义
DATA SEGMENT
DATA ENDS

; 代码段定义
CODE SEGMENT

; 主程序开始
START PROC NEAR
    ASSUME CS:CODE, DS:DATA, SS:_STACK
    
    ; 初始化数据段寄存器
    MOV AX, DATA
    MOV DS, AX
    
    ; === 第一步：运行流水灯 ===
    MOV DX, IO273       ; 设置273输出端口地址
    MOV AX, 0FFFEH      ; 初始状态：只亮第一个灯 (1111111111111110b)
    
RUN_LIGHT_CHASER:
    OUT DX, AX          ; 输出当前LED模式
    CALL Delay          ; 延时
    
    ; 检查是否已经循环到最右边（AX = 7FFFH）
    CMP AX, 7FFFH
    JE READ_SWITCH_STATE ; 如果到达最后状态，转到读取开关
    
    ROL AX, 1           ; 循环左移1位，实现流水灯效果
    JMP RUN_LIGHT_CHASER ; 继续流水灯显示

    ; === 第二步：读取并显示开关状态 ===
READ_SWITCH_STATE:
    MOV DX, IO244       ; 设置244输入端口地址
    IN AX, DX           ; 读取16位开关数据到AX寄存器
    
    ; 检查是否有开关拨动（AX ≠ 0FFFFH）
    CMP AX, 0FFFFH
    JNE DISPLAY_SWITCH  ; 如果有开关拨动，显示开关状态
    
    ; 如果没有开关拨动，全灭灯
    MOV AX, 0FFFFH      ; 全灭灯 (1111111111111111b)
    
DISPLAY_SWITCH:
    MOV DX, IO273       ; 设置273输出端口地址
    OUT DX, AX          ; 将开关状态输出到LED
    
    ; 保存当前开关状态到BX
    MOV BX, AX
    
    ; 短暂延时后重新检查开关状态
    CALL Delay
    CALL Delay
    
    ; 重新读取开关状态，检查是否有变化
    MOV DX, IO244
    IN AX, DX           ; 读取新的开关状态到AX
    
    ; 比较新旧开关状态（BX保存旧状态，AX是新状态）
    CMP AX, BX
    JE DISPLAY_SWITCH   ; 如果开关状态未变，继续显示当前状态
    
    ; 如果开关状态变化，重新开始流水灯
    JMP START

; 延时子程序
Delay PROC NEAR
    MOV CX, 0FFFFH      ; 设置延时计数值
Delay_Loop:
    LOOP Delay_Loop     ; 循环延时
    RET                 ; 返回
Delay ENDP

START ENDP
CODE ENDS
END START
```



## 交通灯代码（修正）

```assembly
COM_ADD EQU 0273H ;IO芯片片选区，CS1范围
PA_ADD EQU 0270H 
PB_ADD EQU 0271H 
PC_ADD EQU 0272H 

_STACK SEGMENT STACK 
    DW 100 DUP(?)       
_STACK ENDS 

DATA SEGMENT 
    LED_Data DB 10111110B     ; 东西绿灯，南北红灯 
             DB 10111111B     ; 东西绿灯闪烁(灭)，南北红灯 
             DB 10111101B     ; 东西黄灯亮，南北红灯 
             DB 11101011B     ; 东西红灯，南北绿灯 
             DB 11111011B     ; 南北绿灯闪烁(灭)，东西红灯 
             DB 11011011B     ; 南北黄灯亮，东西红灯 
DATA ENDS 

CODE SEGMENT 
START PROC NEAR 
    ASSUME CS:CODE, DS:DATA, SS:_STACK 
    MOV AX, DATA       ; AX <- 数据段基地址DATA 
    MOV DS, AX          ; DS <- 数据段基地址 
    
    MOV DX, COM_ADD     ; DX <- 控制字寄存器地址 
    MOV AL, 80H         ; PA、PB、PC为基本输出模式 
    OUT DX, AL          ; 写入控制字 
    
    MOV DX, PA_ADD      ; 灯全熄灭   
    MOV AL, 0FFH        ; 所有灯灭 
    OUT DX, AL 
    
    CALL DL2S           ; 初始延时2秒
    
    LEA BX, LED_Data    ; BX <- 交通灯状态表首地址 

MAIN_LOOP:  
    ; === 状态1：东西绿灯，南北红灯（4/6秒）===
    MOV AL, 0           ; 东西绿灯南北红灯的位移量 
    XLAT 
    OUT DX, AL          ; 东西绿灯，南北红灯 
    CALL DL4S           ; 延时4秒 

    ; === 状态2：东西绿灯闪烁3次（包含在4/6秒内）===
    MOV CX, 3           ; 循环3次 
FLASH_GREEN_EW:  
    MOV AL, 1           ; 东西绿灯闪烁(灭)
    XLAT 
    OUT DX, AL          
    CALL DL500ms        ; 延时500ms 
    
    MOV AL, 0           ; 东西绿灯亮
    XLAT 
    OUT DX, AL          
    CALL DL500ms        ; 延时500ms 
    LOOP FLASH_GREEN_EW ; 循环3次

    ; === 状态3：东西黄灯，南北红灯（4/6秒）===
    MOV AL, 2           ; 东西黄灯亮，南北红灯 
    XLAT  
    OUT DX, AL          
    CALL DL4S           ; 延时4秒 

    ; === 状态4：南北绿灯，东西红灯（4/6秒）===
    MOV AL, 3           ; 南北绿灯，东西红灯 
    XLAT 
    OUT DX, AL 
    CALL DL4S           ; 延时4秒 

    ; === 状态5：南北绿灯闪烁3次（包含在4/6秒内）===
    MOV CX, 3           ; 循环3次 
FLASH_GREEN_NS:  
    MOV AL, 4           ; 南北绿灯闪烁(灭)
    XLAT 
    OUT DX, AL 
    CALL DL500ms 
    
    MOV AL, 3           ; 南北绿灯亮
    XLAT 
    OUT DX, AL 
    CALL DL500ms 
    LOOP FLASH_GREEN_NS ; 循环3次

    ; === 状态6：南北黄灯，东西红灯（4/6秒）===
    MOV AL, 5           ; 南北黄灯亮，东西红灯 
    XLAT 
    OUT DX, AL 
    CALL DL4S 
    
    JMP MAIN_LOOP       ; 循环整个过程

; 延时子程序
DL500ms PROC NEAR       ; 延时500ms 
    PUSH CX             
    MOV CX, 60000       
DL500ms1:  
    LOOP DL500ms1       
    POP CX 
    RET                 
DL500ms ENDP 

DL2S PROC NEAR          ; 延时2秒
    PUSH CX             
    MOV CX, 4           ; 4 * 500ms = 2秒
DL2S1:  
    CALL DL500ms        
    LOOP DL2S1          
    POP CX 
    RET 
DL2S ENDP

DL4S PROC NEAR          ; 延时4秒
    PUSH CX             
    MOV CX, 8           ; 8 * 500ms = 4秒
DL4S1:  
    CALL DL500ms        
    LOOP DL4S1          
    POP CX 
    RET 
DL4S ENDP

START ENDP 
CODE ENDS 
END START
```

































# 第一次实验

编写程序：先按字给3000H-301FH单元赋0000~001FH，再将B4区的静态存贮器3000H-301FH单元中数据按字复制到6000H-601FH的单元中，并校验

选做：检测写入的数据是否正确,如数据正确8个数码管显示全为1，否则显示全为0。



实验二代码：

```assembly
_STACK segment stack
	dw 200 dup(?)
_STACK ends
data segment
data ends
code segment
start proc near
	assume cs:code, ss:_stack, ds:data
	mov ax,8000H
	mov ds,ax
	mov es,ax ;初始化段寄存器，静态存储器入口地址位8000H:0000H
	nop
	
	;第一步，写入3000h-301fh
	mov cx,20h; 定义循环次数
	mov si,3000h;定位
	mov al,0; 初始值0000
int_loop:
		mov [si], al; 赋值
		inc si; 地址单元++
		inc al; 值++
		loop int_loop
	mov cx,20h
	mov si,3000h;初始化
	mov di,6000h
	;第二步，复制3000h-301fh 到 6000h-601fh
	call move
	;第三步，校验成功与否
	mov cx,20h
	mov si,3000h
	mov di,6000h
	cld
	repe cmpsb; 逐个比较[SI]、[DI]数字
	jne error; 有数字不同则触发error、
true: 
	mov bx, 01h; 标识校验正确性
  ;	jmp exit
error: 
	mov bx, 00h

    	
move proc near
	cld; df置0，保证字符串操作向前
	cmp si,di; 分类讨论，比较区域前后顺序
	jz return; 重合则return
	jnb move1; SI在前，直接复制，因为向前复制不会有冲突
	
	;下面是SI在后，则可能有冲突，于是采用向后复制
	add si,cx
	dec si; 定位到SI区域末尾
	add di,cx
	dec di; 定位到DI区域末尾
	std; df置1，字符串向后操作

move1: rep movsb; 字符串赋值操作
return: ret
move endp

exit:
;    jmp $ 
   mov ax, 4c00h
   int 21h

start endp
code ends
	end start
```
